% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/produce_info_tables.R
\name{parse_table}
\alias{parse_table}
\title{Parse and check a dataframe}
\usage{
parse_table(
  df,
  required_names = NULL,
  required_patterns = NULL,
  required_types = cols()
)
}
\arguments{
\item{df}{A \code{data.frame}.}

\item{required_names}{Either \code{NULL} or a character vector of column
names that should appear in the table. The function will produce an error if
any of these column names is missing from the table. Default: \code{NULL}}

\item{required_patterns}{Either \code{NULL} or a character vector. If it
is a named vector, its names will be interpreted as column names.
If it has no names, it should be the same length as \code{required_names},
which will be used as a vector of corresponding column names. The elements of
\code{required_patterns} should be valid (ICU) regular expressions. If an
input column has a corresponding pattern, every entry in the column must
contain a match of that pattern.
Default: \code{NULL}}

\item{required_types}{A \code{cols()} specification giving the types to
which input columns should be converted, e.g.:
\code{cols(age = "i", weight = "d", .default = "c")}. Each input column
covered by the specification (i.e. all columns if \code{.default} is set)
should be convertible to the specified type. Input columns not covered by the
specification will be converted to types guessed from their contents.
Default: \code{cols()}}
}
\value{
A \code{data.frame} of the same type as \code{df}, where column types
have been converted to match the \code{required_types} specification.
}
\description{
This function converts a dataframe's columns to character, checks them
against custom specifications and then changes their types as desired. Any
mismatch between specifications and the input table will result in an error.
}
\examples{
library("tibble")
library("readr")
library("magrittr")
input <- tibble(x = c("A_B", "C_D"), y = c("1", "2"))
expected <- tibble(x = c("A_B", "C_D"), y = as.integer(c(1, 2)))
# It is not an error to require a pattern or a type for a column that is
# absent from the input table, e.g. "z"
output <-
    input \%>\%
    parse_table(
        required_names = c("y"),
        required_patterns = c(x = "_", z = "^[1-5]$"),
        required_types = cols(y = "i", z = "i")
    )
stopifnot(identical(output, expected))

}
